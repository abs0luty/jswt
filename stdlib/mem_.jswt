const __W_SIZE = 4; // Word and header/footer size (bytes)
const __D_SIZE = 8; // Double word size (bytes)
const __CHUNK_SIZE = 128;
const __PAGE_SIZE = 1; // Extend the heap by this amount

let __mem_heap = 0; // Pointer to first byte of the heap
let __mem_brk = 16; // Pointer to last byte of the heap + 1
let __mem_max_addr = 256; // Max legal heap + 1

let __heap_list_ptr = 16;

function __mem_sbrk(size: i32): i32 {
    let oldBrk = __mem_brk;
    let newSize = __mem_brk + size;
    if(newSize > __mem_max_addr) {
        return 0;
    }
    __mem_brk = __mem_brk + size;
    return oldBrk;
}

// Initialize the memory manager runtime
function __mm_init() {
    // Empty heap has already been allocated by the module loader
    __heap_list_ptr = __mem_sbrk(4 * __W_SIZE);
    i32Store(__heap_list_ptr, 0); // Allignment Padding
    i32Store(__heap_list_ptr + 1 * __W_SIZE, __pack(__D_SIZE, 1)); // Prologue Header
    i32Store(__heap_list_ptr + 2 * __W_SIZE, __pack(__D_SIZE, 1)); // Prologue Footer
    i32Store(__heap_list_ptr + 3 * __W_SIZE, __pack(0, 1)); // Epilogue Header
    __heap_list_ptr = __heap_list_ptr + 2 * __W_SIZE;
    println(__heap_list_ptr);

    let bp = __mem_sbrk(__CHUNK_SIZE);
    i32Store(__headerPointer(bp), __pack(__CHUNK_SIZE, 0));
    i32Store(__footerPointer(bp), __pack(__CHUNK_SIZE, 0));
    bp = __nextBlockPointer(bp);
    i32Store(__headerPointer(bp), __pack(0, 1));
}

function __mm_free(blockPointer: i32) {
    let headerPointer = __headerPointer(blockPointer);
    let size = __getSize(headerPointer);

    i32Store(headerPointer, __pack(size, 0));

    let footerPointer = __footerPointer(blockPointer);
    i32Store(footerPointer, __pack(size, 0));
    // TODO - coalesce blocks
}

function __mm_malloc(size: i32): i32 {
    if (size == 0) {
        return 0;
    }

    let adjustedBlockSize = 0;
    if (size <= __D_SIZE) {
        adjustedBlockSize = 2 * __D_SIZE;
    } else {
        // Don't have parens yet
        let temp = __D_SIZE - 1;
        temp = size + __D_SIZE + temp;
        temp = temp / __D_SIZE;
        adjustedBlockSize = temp * __D_SIZE;
    }

    let blockPointer = __findFit(adjustedBlockSize);
    if (blockPointer != 0) {
        __place(blockPointer, adjustedBlockSize);
        return blockPointer;
    }

    // TODO extend heap then place
    return 0;
}

function __findFit(blockSize: i32): i32 {
    let blockPointer = __heap_list_ptr;
    while (__getSize(__headerPointer(blockPointer)) > 0) {
        let isAllocated = __getAlloc(__headerPointer(blockPointer));
        
        let size = __getSize(__headerPointer(blockPointer));
        println(size);
        if (isAllocated == 0) {
            if (blockSize <= size) {
                return blockPointer;
            }
        }

        blockPointer = __nextBlockPointer(blockPointer);
    }

    return 0;
}

function __place(blockPointer: i32, size: i32) {
    let cSize = __getSize(__headerPointer(blockPointer));
    let remainder = cSize - size;

    if (remainder >= 2 * __D_SIZE) {
        i32Store(__headerPointer(blockPointer), __pack(size, 1));
        i32Store(__footerPointer(blockPointer), __pack(size, 1));

        let nextBlockPointer = __headerPointer(blockPointer);
        i32Store(__headerPointer(nextBlockPointer), __pack(remainder, 1));
        i32Store(__footerPointer(nextBlockPointer), __pack(remainder, 1));
    } else {
        i32Store(__headerPointer(blockPointer), __pack(cSize, 1));
        i32Store(__footerPointer(blockPointer), __pack(cSize, 1));
    }
}

// Computed header pointer from the given block pointer
function __headerPointer(blockPointer: i32): i32 {
    return blockPointer - __W_SIZE;
}

// Computer footer pointer from the given block pointer
function __footerPointer(blockPointer: i32): i32 {
    return blockPointer + __getSize(__headerPointer(blockPointer)) - __D_SIZE;
}

function __nextBlockPointer(blockPointer: i32): i32 {
    return blockPointer + __getSize(blockPointer - __W_SIZE);
}

function __prevBlockPointer(blockPointer: i32): i32 {
    return blockPointer - __getSize(blockPointer - __D_SIZE);
}

// Size of the block Assuming that it's a multiple of 8
// The last 3 bits are assumed to be always 0
function __getSize(address: i32): i32 {
    let value = i32Load(address);
    return value & i32not(7);
}

// Compute the allocation bit. The last bit is of the block header/footer
// Are reserved as indicators of whether the block is allocated
function __getAlloc(address: i32): i32 {
    return i32Load(address) & 1;
}

// Pack size and allocated bit into a word
function __pack(size: i32, alloc: i32): i32 {
    return size | alloc;
}

// Single max utility function
function __max(a: i32, b: i32): i32 {
    if (a > b) {
        return a;
    }
    return b;
}

@wast("(local.get $index)(i32.load offset=0 align=4)(return)")
function i32Load(index: i32): i32 { }

@wast("(local.get $index)(local.get $value)(i32.store align=4)")
function i32Store(index: i32, value: i32) { }

// i32.not an valid i32 instruction. So we have to rely on
// an intentional underflow. Discussion here
// https://github.com/WebAssembly/design/issues/379
function i32not(value: i32): i32 { return 0 - value; }