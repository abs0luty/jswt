const __W_SIZE = 4; // Word and header/footer size (bytes)
const __D_SIZE = 8; // Double word size (bytes)

// Offset by 16 bytes 
let __heapPointer = 16;

// Naive bump allocator
// Allocates a block by adding a header and footer
// then proceeds to increment the heap pointer
function __mm_malloc(size: i32): i32 {

    if (size == 0) {
        return 0;
    }

    // Compute adjusted block size which needs to be
    // a multiple of 8
    let adjustedBlockSize = 0;
    if (size <= __D_SIZE) {
        adjustedBlockSize = 2 * __D_SIZE;
    } else {
        // Don't have parens yet
        adjustedBlockSize = nextMultipleOf8(size) + __D_SIZE;
    }

    // Place the header and footer then 
    // bump the allocation pointer
    __place(__heapPointer, adjustedBlockSize);
    let oldPointer = __heapPointer;
    __heapPointer = __heapPointer + adjustedBlockSize;
    
    return oldPointer;
}


function __place(blockPointer: i32, size: i32) {
    i32Store(__headerPointer(blockPointer), __pack(size, 1));
    i32Store(__footerPointer(blockPointer), __pack(size, 1));
}

// Computed header pointer from the given block pointer
function __headerPointer(blockPointer: i32): i32 {
    return blockPointer - __W_SIZE;
}

// Computer footer pointer from the given block pointer
function __footerPointer(blockPointer: i32): i32 {
    return blockPointer + __getSize(__headerPointer(blockPointer)) - __D_SIZE;
}

function __nextBlockPointer(blockPointer: i32): i32 {
    return blockPointer + __getSize(blockPointer - __W_SIZE);
}

function __prevBlockPointer(blockPointer: i32): i32 {
    return blockPointer - __getSize(blockPointer - __D_SIZE);
}

// Size of the block Assuming that it's a multiple of 8
// The last 3 bits are assumed to be always 0
function __getSize(address: i32): i32 {
    let value = i32Load(address);
    return value & i32not(7);
}

// Compute the allocation bit. The last bit is of the block header/footer
// Are reserved as indicators of whether the block is allocated
function __getAlloc(address: i32): i32 {
    return i32Load(address) & 1;
}

// Pack size and allocated bit into a word
function __pack(size: i32, alloc: i32): i32 {
    return size | alloc;
}


// Single max utility function
function __max(a: i32, b: i32): i32 {
    if (a > b) {
        return a;
    }
    return b;
}

@wast("(local.get $index)(i32.load offset=0 align=4)(return)")
function i32Load(index: i32): i32 { }

@wast("(local.get $index)(local.get $value)(i32.store align=4)")
function i32Store(index: i32, value: i32) { }

// i32.not an valid i32 instruction. So we have to rely on
// an intentional underflow. Discussion here
// https://github.com/WebAssembly/design/issues/379
// https://github.com/WebAssembly/design/issues/701
@wast("(i32.xor (local.get $value) (i32.const -1))")
function i32not(value: i32): i32 { }

@wast("(i32.and (i32.add (local.get $value) (i32.const 7)) (i32.const -8))")
function nextMultipleOf8(value: i32): i32 { }