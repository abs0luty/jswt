// @ts-nocheck

import "./memory.jswt";
import "../stdlib/math.jswt";

let maxAddr = 65536;
let isInit = false;

function init() {
    // Setup header
    hdrSetSize(0, maxAddr - 8);
    hdrSetFree(0, true);

    // Setup footer
    hdrSetSize(maxAddr - 4, maxAddr - 8);
    hdrSetFree(maxAddr - 4, true);

    isInit = true;
}

// read payload_size from header/footer given pointer to header/footer
@inline("")
function hdrGetSize(pointer: i32): i32 {
    return i32Load(pointer) & 0xFFFFFFFC;
}

function hdrSetSize(pointer: i32, n: i32) {
    let size = i32Load(pointer) & 0x00000003;
    i32Store(pointer, size | n);
}

@inline("")
function hdrGetFree(pointer: i32): boolean {
    return i32Load(pointer) & 0x00000001;
}

@inline("")
function hdrSetFree(pointer: i32, isFree: boolean) {
    let alloc = i32Load(pointer) & 0xFFFFFFFE;
    i32Store(pointer, alloc | isFree);
}

function align4(value: i32): i32 {
    let temp = value + 3;
    return temp & 0xFFFFFFFC;
}



// ;; read is_free from header/footer
// (func $hdr_get_free (param $ptr i32) (result i32)
//   (i32.and (i32.load (local.get $ptr)) (i32.const 0x00000001))
// )

// i32.not an valid i32 instruction. So we have to rely on
// an intentional underflow. Discussion here
// https://github.com/WebAssembly/design/issues/379
// https://github.com/WebAssembly/design/issues/701
@wast("(i32.xor (local.get $value) (i32.const -1))")
function i32not(value: i32): i32 { }


// @wast("(i32.and (i32.add (local.get $value) (i32.const 7)) (i32.const -8))")
// function nextMultipleOf8(value: i32): i32 { }

// // Naive bump allocator
// // Allocates a block by adding a header and footer
// // then proceeds to increment the heap pointer
// function __mm_malloc(size: i32): i32 {

//     if (size == 0) {
//         return 0;
//     }

//     // Compute adjusted block size which needs to be
//     // a multiple of 8
//     let adjustedBlockSize = 0;
//     if (size <= __D_SIZE) {
//         adjustedBlockSize = 2 * __D_SIZE;
//     } else {
//         // Don't have parens yet
//         adjustedBlockSize = nextMultipleOf8(size) + __D_SIZE;
//     }

//     // Place the header and footer then 
//     // bump the allocation pointer
//     __place(__heapPointer, adjustedBlockSize);
//     let oldPointer = __heapPointer;
//     __heapPointer = __heapPointer + adjustedBlockSize;

//     return oldPointer;
// }


// function __place(blockPointer: i32, size: i32) {
//     i32Store(__headerPointer(blockPointer), __pack(size, 1));
//     i32Store(__footerPointer(blockPointer), __pack(size, 1));
// }

// // Computed header pointer from the given block pointer
// function __headerPointer(blockPointer: i32): i32 {
//     return blockPointer - __W_SIZE;
// }

// // Computer footer pointer from the given block pointer
// function __footerPointer(blockPointer: i32): i32 {
//     return blockPointer + __getSize(__headerPointer(blockPointer)) - __D_SIZE;
// }

// function __nextBlockPointer(blockPointer: i32): i32 {
//     return blockPointer + __getSize(blockPointer - __W_SIZE);
// }

// function __prevBlockPointer(blockPointer: i32): i32 {
//     return blockPointer - __getSize(blockPointer - __D_SIZE);
// }

// // Size of the block Assuming that it's a multiple of 8
// // The last 3 bits are assumed to be always 0
// function __getSize(address: i32): i32 {
//     let value = i32Load(address);
//     return value & i32not(7);
// }

// // Compute the allocation bit. The last bit is of the block header/footer
// // Are reserved as indicators of whether the block is allocated
// function __getAlloc(address: i32): i32 {
//     return i32Load(address) & 1;
// }

// // Pack size and allocated bit into a word
// function __pack(size: i32, alloc: i32): i32 {
//     return size | alloc;
// }

// // i32.not an valid i32 instruction. So we have to rely on
// // an intentional underflow. Discussion here
// // https://github.com/WebAssembly/design/issues/379
// // https://github.com/WebAssembly/design/issues/701
// @wast("(i32.xor (local.get $value) (i32.const -1))")
// function i32not(value: i32): i32 { }

// @wast("(i32.and (i32.add (local.get $value) (i32.const 7)) (i32.const -8))")
// function nextMultipleOf8(value: i32): i32 { }