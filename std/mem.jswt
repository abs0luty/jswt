let __W_SIZE = 4; // Word and header/footer size (bytes)
let __D_SIZE = 8; // Double word size (bytes)
let __PAGE_SIZE = 1; // Extend the heap by this amount

let __MEM_HEAP = 0; // Pointer to first byte of the heap
let __MEM_HEAP_BRK = 1; // Pointer to last byte of the heap + 1

// Initialize the memory manager runtime
function __mm_init(): i32 {
    return 0;
}

@wast("(local.get 0)(call $i32Load)(i32.const 7)(call $i32not)(i32.and)(return)")
function __getSize(address: i32): i32 {
    // let value = i32Load(address);
    // return value & ~0x07;
}

function __getAlloc(address: i32): i32 {
    return i32Load(address) & 1;
}

// Pack size and allocated bit into a word
function __pack(size: i32, alloc: i32): i32 {
    return size | alloc;
}

@wast("(local.get $index)(i32.load offset=0 align=4)(return)")
function i32Load(index: i32): i32 { }

@wast("(local.get $index)(local.get $value)(i32.store align=4)")
function i32Store(index: i32, value: i32) { }

// i32.not an valid i32 instruction. So we have to rely on
// an intentional underflow. Discussion here
// https://github.com/WebAssembly/design/issues/379
function i32not(value: i32): i32 { return 0 - value; }